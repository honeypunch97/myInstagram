import { toast } from "react-toastify";
import { User } from "firebase/auth";
import { TFeed } from "../types/feed";
import { arrayRemove, arrayUnion, doc, getDoc, increment, updateDoc } from "firebase/firestore";
import { db } from "../firebase";

let isProcessing = false;
//옵티미스틱 업데이트(Optimistic Update) 이 방법은 서버 응답을 기다리지 않고 UI를 먼저 업데이트하는 방식입니다. 사용자가 '좋아요'를 눌렀을 때, 서버에 요청을 보내는 동시에 UI를 업데이트합니다. 서버로부터 응답이 오면 그때 실제 데이터를 업데이트하며, 오류가 발생한 경우에는 사용자에게 알리고 UI를 원래 상태로 돌립니다.
const updateFeedData = (feedData: TFeed[] | null, id: string, userId: string | undefined): TFeed[] => {
  return (feedData || []).map(item => {
    if (item.id !== id) return item;

    let updatedSaves = item.save;
    if (userId) {
      if (item.save.includes(userId)) {
        updatedSaves = item.save.filter(saveItem => saveItem !== userId);
      } else {
        updatedSaves = [...item.save, userId];
      }
    }
    return { ...item, save: updatedSaves };
  });
};

export const toggleSave = async (
  user: User | null,
  id: string,
  feedData: TFeed[] | null,
  setFeedData: (feedData: TFeed[]) => void,
) => {
  if (isProcessing) return;
  isProcessing = true;

  const userId = user?.uid;
  const ref = doc(db, "feed", id);
  const snap = await getDoc(ref);
  if (!user) {
    toast.info("로그인이 필요합니다.");
    return;
  } else if (!snap.exists) {
    toast.error("게시물을 찾을 수 없습니다.");
    return;
  }
  const data = snap.data();
  const saveArr = data?.save || [];

  try {
    setFeedData(updateFeedData(feedData, id, userId));
    if (saveArr.includes(userId)) {
      await updateDoc(ref, {
        save: arrayRemove(userId),
      });
    } else {
      await updateDoc(ref, {
        save: arrayUnion(userId),
      });
    }
  } catch (e) {
    console.log(e);
    setFeedData(updateFeedData(feedData, id, userId));
    toast.error("오류로인해 이전 상태로 되돌립니다. (피드저장)");
  } finally {
    isProcessing = false;
  }
};
